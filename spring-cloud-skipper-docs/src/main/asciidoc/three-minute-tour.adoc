[[three-minute-tour]]
= Three minute Tour

Picking up from where the <<three-second-tour>> left off, this section walks through the additional commands and
other features of Skipper.  Each section walks through the same set of operations, but for a different platform.

[[tour-local]]
== Local machine

Start up the server and shell as in the <<three-second-tour, three second tour>>.

Let's install and then update the hello world application.

[source,bash,options="nowrap"]
----
skipper:>install --release-name helloworldlocal --package-name helloworld --package-version 1.0.0 --properties spec.applicationProperties.server.port=8099
Released helloworldlocal. Now at version v1.
----

You can now curl the `greeting` endpoint.
```
$ curl http://localhost:8099/greeting
Hello World!
$ curl http://localhost:8099/about
Hello World v1.0.0.RELEASE
```

We will use a YAML file to update the release.  This application contains a Spring Boot `@ConfigurationProperty` named `helloworld.greeting`, so we will set that along with a standard Spring Boot property `endpoints.sensitive=false`.  We will also bump the memory up to 2G, make the Boot actuator endpoint not sensitive and set the port to 8100.

The `helloworld-upgrade-local.yml` file contains
----
spec:
  applicationProperties:
    server.port: 8100
    endpoints.sensitive: false
    helloworld.greeting: yo
  deploymentProperties:
    spring.cloud.deployer.memory: 2048m
----

The `upgrade` command
[source,bash,options="nowrap"]
----
skipper:>upgrade --release-name helloworldlocal --package-name helloworld --package-version 1.0.1 --file /home/mpollack/helloworld-upgrade-local.yml
helloworldlocal has been upgraded.  Now at version v2.
----

The current upgrade strategy is very simple, if the new app is healthy, the old app is removed.  There is not a rolling upgrade option, all new apps are deployed, checked for health, and then previous versions removed.
More flexible upgrade strategies are planned along with the introduction of the https://projects.spring.io/spring-statemachine/[Spring Cloud State Machine] project to orchestrate the update process.


You can now curl the `greeting` endpoint and the `about` endpoint or view them in your browser.
```
$ curl http://localhost:8100/greeting
yo
$ curl http://localhost:8100/about
Hello World v1.0.1.RELEASE
```

The `list` command shows you the current `DEPLOYED` and `DELETED` releases for every release name.
In this case there is just one entry

[source,bash,options="nowrap"]
----
skipper:>list
╔═══════════════╤═══════╤═════════════╤════════╤══════════╤═════════╤═════════╤════════════════════════════════════════════════════╗
║     Name      │Version│Last updated │ Status │ Package  │ Package │Platform │                  Platform Status                   ║
║               │       │             │        │   Name   │ Version │  Name   │                                                    ║
╠═══════════════╪═══════╪═════════════╪════════╪══════════╪═════════╪═════════╪════════════════════════════════════════════════════╣
║helloworldlocal│2      │Fri Oct 27   │DEPLOYED│helloworld│1.0.1    │default  │[helloworldlocal.helloworld-v2], State =            ║
║               │       │16:39:03 IST │        │          │         │         │[helloworldlocal.helloworld-v2-0=deployed]          ║
║               │       │2017         │        │          │         │         │                                                    ║
╚═══════════════╧═══════╧═════════════╧════════╧══════════╧═════════╧═════════╧════════════════════════════════════════════════════╝
----

You can get the full history of the release using the `history` command.
[source,bash,options="nowrap"]
----
skipper:>history --release-name helloworldlocal
╔═══════╤════════════════════════════╤════════╤════════════╤═══════════════╤════════════════╗
║Version│        Last updated        │ Status │Package Name│Package Version│  Description   ║
╠═══════╪════════════════════════════╪════════╪════════════╪═══════════════╪════════════════╣
║2      │Fri Oct 27 16:39:03 IST 2017│DEPLOYED│helloworld  │1.0.1          │Upgrade complete║
║1      │Fri Oct 27 16:37:59 IST 2017│DELETED │helloworld  │1.0.0          │Delete complete ║
╚═══════╧════════════════════════════╧════════╧════════════╧═══════════════╧════════════════╝
----

To see what changed, you can look at the Skipper manifest for each release using the `manifest get` command.
  A `manifest diff` command is coming in the next release.

[source,bash,options="nowrap"]
----
skipper:>manifest get --release-name helloworldlocal --release-version 2

---
# Source: helloworld.yml
apiVersion: skipper/v1
kind: SpringCloudDeployerApplication
metadata:
  name: helloworld
  type: demo
spec:
  resource: maven://org.springframework.cloud.samples:spring-cloud-skipper-samples-helloworld:1.0.1.RELEASE
  applicationProperties:
    server.port: 8100
    endpoints.sensitive: false
    helloworld.greeting: yo
  deploymentProperties:
    spring.cloud.deployer.memory: 2048m
    spring.cloud.deployer.count: 1
----

and

[source,bash,options="nowrap"]
----
skipper:>manifest get --release-name helloworldlocal --release-version 1

---
# Source: helloworld.yml
apiVersion: skipper/v1
kind: SpringCloudDeployerApplication
metadata:
  name: helloworld
  type: demo
spec:
  resource: maven://org.springframework.cloud.samples:spring-cloud-skipper-samples-helloworld:1.0.0.RELEASE
  applicationProperties:
    server.port: 8099
  deploymentProperties:
----

Next we will use the `rollback` command to deploy an older version of the application.
Since we have the manifest for that version, we have all we need to redeploy an earlier release.

[source,bash,options="nowrap"]
----
skipper:>rollback --release-name helloworldlocal --release-version 1
helloworldlocal has been rolled back.  Now at version v3.
----

The history now shows a new `v3` version, even though it is identical in terms of app behavior to the `v2` version.

[source,bash,options="nowrap"]
----
skipper:>history --release-name helloworldlocal
╔═══════╤════════════════════════════╤════════╤════════════╤═══════════════╤════════════════╗
║Version│        Last updated        │ Status │Package Name│Package Version│  Description   ║
╠═══════╪════════════════════════════╪════════╪════════════╪═══════════════╪════════════════╣
║3      │Fri Oct 27 16:42:47 IST 2017│DEPLOYED│helloworld  │1.0.0          │Upgrade complete║
║2      │Fri Oct 27 16:39:03 IST 2017│DELETED │helloworld  │1.0.1          │Delete complete ║
║1      │Fri Oct 27 16:37:59 IST 2017│DELETED │helloworld  │1.0.0          │Delete complete ║
╚═══════╧════════════════════════════╧════════╧════════════╧═══════════════╧════════════════╝
----


You can now curl the `greeting` endpoint.
```
$ curl http://localhost:8099/greeting
Hello World!
$ curl http://localhost:8099/about
Hello World v1.0.0.RELEASE
```

[[tour-cloud-foundry]]
== Cloud Foundry

Skipper uses a Relational Database to store state.
 In this tour we will just be using the embedded database.
 You can modify the example manifest file below to bind to a relational database service instead of using the embedded database. You can find an example <<building, here>>.

[source,bash,options="nowrap"]
----
applications:
- name: mlp-skipper
  host: mlp-skipper
  memory: 1G
  disk_quota: 1G
  timeout: 180
  instances: 1
  path: spring-cloud-skipper-server-1.0.0.M1.jar
env:
    SPRING_APPLICATION_NAME: mlp-skipper
    SPRING_CLOUD_SKIPPER_SERVER_ENABLE_LOCAL_PLATFORM: false
    SPRING_CLOUD_SKIPPER_SERVER_STRATEGIES_HEALTHCHECK.TIMEOUTINMILLIS: 300000
    SPRING_CLOUD_SKIPPER_SERVER_PLATFORM_CLOUDFOUNDRY_ACCOUNTS[cf-dev]_CONNECTION_URL: https://api.run.pivotal.io
    SPRING_CLOUD_SKIPPER_SERVER_PLATFORM_CLOUDFOUNDRY_ACCOUNTS[cf-dev]_CONNECTION_ORG: scdf-ci
    SPRING_CLOUD_SKIPPER_SERVER_PLATFORM_CLOUDFOUNDRY_ACCOUNTS[cf-dev]_CONNECTION_SPACE: space-mark
    SPRING_CLOUD_SKIPPER_SERVER_PLATFORM_CLOUDFOUNDRY_ACCOUNTS[cf-dev]_CONNECTION_USERNAME: <your-username>
    SPRING_CLOUD_SKIPPER_SERVER_PLATFORM_CLOUDFOUNDRY_ACCOUNTS[cf-dev]_CONNECTION_PASSWORD: <your-password>
    SPRING_CLOUD_SKIPPER_SERVER_PLATFORM_CLOUDFOUNDRY_ACCOUNTS[cf-dev]_CONNECTION_SKIP_SSL_VALIDATION: false
    SPRING_CLOUD_SKIPPER_SERVER_PLATFORM_CLOUDFOUNDRY_ACCOUNTS[cf-dev]_DEPLOYMENT_DELETE_ROUTES: false
    SPRING_CLOUD_SKIPPER_SERVER_PLATFORM_CLOUDFOUNDRY_ACCOUNTS[cf-dev]_DEPLOYMENT_DOMAIN: cfapps.io
----

This defines `cf-dev` as a named Cloud Foundry account.
You can define multiple Cloud Foundry accounts and reference them in the shell commands when ever there is a command option for `--platform-name`.

The `deployment.deleteRoutes` property is important if you are deploying HTTP apps.  When doing an upgrade, setting
this to `false` prevents the routes from disappearing after deleting the old application.  The underlying Spring Cloud
Deployer library for Cloud Foundry has this value set to `true` as the default.

Note you can also run the Skipper Server locally and deploy to Cloud Foundry.
In this case, it is more convenient to specify the configuration as a `skipper.yml` file, shown below, and start the server with the option `--spring.config.location=skipper.yml`

----
spring:
  cloud:
    skipper:
      server:
        enableLocalPlatform: false
        platform:
          cloudfoundry:
            accounts:
              cf-dev:
                connection:
                  url: https://api.run.pivotal.io
                  org: scdf-ci
                  space: space-mark
                  username: <your-username>
                  password: <your-password>
                  skipSslValidation: false
                deployment:
                  deleteRoutes: false
                  domain: cfapps.io
----

When you start the Skipper shell, by default it tries to look for the Skipper server on the same (local) machine.
To specify the Skipper server that is running on Cloud Foundry, use the CF route with the `config` command

```
skipper:>config --uri https://mlp-skipper.cfapps.io/api
Successfully targeted https://mlp-skipper.cfapps.io/api
```

The `repo list` command shows the `experimental` and `local` repositories, since they are configured by default.
[source,bash,options="nowrap"]
----
skipper:>repo list
╔════════════╤═══════════════════════════════════════════════════════════╤═════╤═════╗
║    Name    │                            URL                            │Local│Order║
╠════════════╪═══════════════════════════════════════════════════════════╪═════╪═════╣
║experimental│http://skipper-repository.cfapps.io/repository/experimental│false│0    ║
║local       │http://d4d6d1b6-c7e5-4226-69ec-01d4:7577                   │true │1    ║
╚════════════╧═══════════════════════════════════════════════════════════╧═════╧═════╝
----

and the `search` command shows
[source,bash,options="nowrap"]
----
skipper:>search
╔═════════════════╤═══════╤════════════════════════════════════════════════════════════════════════════════╗
║      Name       │Version│                                  Description                                   ║
╠═════════════════╪═══════╪════════════════════════════════════════════════════════════════════════════════╣
║helloworld       │1.0.1  │The app has two endpoints, /about and /greeting in Portuguese.  Maven resource. ║
║helloworld       │1.0.0  │The app has two endpoints, /about and /greeting in English.  Maven resource.    ║
║helloworld-docker│1.0.1  │The app has two endpoints, /about and /greeting in Portuguese.  Docker resource.║
║helloworld-docker│1.0.0  │The app has two endpoints, /about and /greeting in English.  Docker resource.   ║
╚═════════════════╧═══════╧════════════════════════════════════════════════════════════════════════════════╝
----

The command `platform list` shows which platforms the server has been configured with, in this case just one Cloud Foundry platform.  Disabling the local platform with the property `enableLocalPlatform = false` is why the default `local` platform does not appear.

[source,bash,options="nowrap"]
----
skipper:>platform list
╔══════╤════════════╤═════════════════════════════════════════════════════════════════════════╗
║ Name │    Type    │                               Description                               ║
╠══════╪════════════╪═════════════════════════════════════════════════════════════════════════╣
║cf-dev│cloudfoundry│org = [scdf-ci], space = [space-mark], url = [https://api.run.pivotal.io]║
╚══════╧════════════╧═════════════════════════════════════════════════════════════════════════╝
----

Let's install the Hello World app, specifically, the maven based artifact.

[source,bash,options="nowrap"]
----
skipper:>install --release-name helloworldpcf --package-name helloworld --package-version 1.0.0 --platform-name cf-dev --properties spec.deploymentProperties.spring.cloud.deployer.cloudfoundry.route=helloworldpcf.cfapps.io
Released helloworldpcf. Now at version v1.
----

If you do not specify `--platform-name cf-dev` the command will fail since the command property defaults to a platform named `default`.  Instead of specifying it, you can register this Cloud Foundry Platform account in the manifest with the name `default` instead of `cf-dev`.

You can monitor the process using the `status command`.

[source,bash,options="nowrap"]
----
skipper:>status --release-name helloworldpcf
╔═══════════════╤════════════════════════════════════════════════╗
║Last Deployed  │Tue Oct 24 22:54:30 EDT 2017                    ║
║Status         │DEPLOYED                                        ║
║Platform Status│The applications are being deployed.            ║
║               │[helloworldpcf-helloworld-v1], State = [partial]║
╚═══════════════╧════════════════════════════════════════════════╝
----

Eventually the Platform Status will say `All applications have been successfully deployed.`

Note that the status `DEPLOYED` above indicates that Skipper has told the platform to deploy.  Skipper does not keep track of the intermediate states 'deploying' or 'deleting'.

A `cf apps` command will now have a new listing for this deployed application.

[source,bash,options="nowrap"]
----
$ cf apps
Getting apps in org scdf-ci / space space-mark as mpollack@gopivotal.com...
OK

name                          requested state   instances   memory   disk   urls
helloworldpcf-helloworld-v1   started           1/1         1G       1G     helloworldpcf.cfapps.io
----

You can now curl the `greeting` endpoint and the `about` endpoint.

[source,bash,options="nowrap"]
----
$ curl http://helloworldpcf.cfapps.io/greeting
Hello World!
$ curl http://helloworldpcf.cfapps.io/about
Hello World v1.0.0.RELEASE
----

The name of the application is based on the convention <release-name>-<package-name>-v<incrementing-counter>.

Also note that we specified a route for this application that is different than the application's name.
The deployment property `spring.cloud.deployer.cloudfoundry.route` is set to something that will not change across the deployment of different versions of this application, in this case `helloworldpcf.cfapps.io`.

The package provides a means to template the application version, application properties and deployment properties that are used to deploy the application to Cloud Foundry.
The `manifest get` command shows the final YAML file which is passed off to the Spring Cloud Deployer Library.

[source,bash,options="nowrap"]
----
skipper:>manifest get --release-name helloworldpcf

---
# Source: helloworld.yml
apiVersion: skipper/v1
kind: SpringCloudDeployerApplication
metadata:
  name: helloworld
  type: demo
spec:
  resource: maven://org.springframework.cloud.samples:spring-cloud-skipper-samples-helloworld:1.0.0.RELEASE
  applicationProperties:
  deploymentProperties:
    spring.cloud.deployer.cloudfoundry.route: helloworldpcf.cfapps.io
----

The manifest is in a Kubernetes Resource file inspired format.  By looking at the manifest you can see which maven artifact was used and which properties were set before the final push to Cloud Foundry.
The metadata values that are present will be used in the next release to support searching for releases based on those values.

Since it is somewhat awkward to specify multiple flattened out YAML values for the `--properties` argument in the shell, you can also specify the location of a YAML file when installing or upgrading.
We will use a YAML file to update the release.  This application contains a Spring Boot `@ConfigurationProperty` named `helloworld.greeting`, so we will set that along with a standard Spring Boot property `endpoints.sensitive=false`.  We will also bump the memory up to 2G.

----
spec:
  applicationProperties:
    endpoints.sensitive: false
    helloworld.greeting: yo
  deploymentProperties:
    spring.cloud.deployer.cloudfoundry.route: helloworldpcf.cfapps.io
    spring.cloud.deployer.memory: 2048m
----

The `upgrade` command
[source,bash,options="nowrap"]
----
skipper:>upgrade --release-name helloworldpcf --package-name helloworld --package-version 1.0.0 --file /home/mpollack/helloworld-upgrade.yml
helloworldpcf has been upgraded.  Now at version v2.
----

Will start another instance of the hello world application. If you do not specify `--package-version` it will pick the latest version of the `helloworld` package.  You do not need to specify the `--platform-name` as it will always be where the current application was deployed.

The `cf apps` and `cf routes` command shows

[source,bash,options="nowrap"]
----
$ cf apps
Getting apps in org scdf-ci / space space-mark as mpollack@gopivotal.com...
OK

name                          requested state   instances   memory   disk   urls
helloworldpcf-helloworld-v1   started           1/1         1G       1G     helloworldpcf.cfapps.io
helloworldpcf-helloworld-v2   stopped           0/1         2G       1G     helloworldpcf.cfapps.io
----

and

[source,bash,options="nowrap"]
----
$ cf routes
Getting routes for org scdf-ci / space space-mark as mpollack@gopivotal.com ...

space        host                          domain      port   path   type   apps                                                      service
space-mark   helloworldpcf                 cfapps.io                        helloworldpcf-helloworld-v1,helloworldpcf-helloworld-v2

----

At this point Skipper is looking to see if the health endpoint of the Boot application is ok.
The property `spring.cloud.skipper.server.strategies.healthcheck.timeoutInMillis` is the maximum time the upgrade process will wait for a healthy app.
The default value is 5 minutes.
Skipper will fail the deployment if it is not healthy within that time.
The property `spring.cloud.skipper.server.strategies.healthcheck.sleepInMillis` is how long to sleep between health checks.

The current upgrade strategy is very simple, if the new app is healthy, the old app is removed.  There is not a rolling upgrade option, all new apps are deployed, checked for health, and then previous versions removed.
More flexible upgrade strategies are planned along with the introduction of the https://projects.spring.io/spring-statemachine/[Spring Cloud State Machine] project to orchestrate the update process.

You can now curl the `greeting` endpoint and the `about` endpoint.
[source,bash,options="nowrap"]
----
$ curl http://helloworldpcf.cfapps.io/greeting
yo
$ curl http://helloworldpcf.cfapps.io/about
Hello World v1.0.0.RELEASE
----

The `list` command shows you the current `DEPLOYED` and `DELETED` releases for every release name.
In this case there is just one entry

[source,bash,options="nowrap"]
----
╔══════════════╤═══════╤══════════════════════════╤════════╤═══════════╤══════════════╤════════════╤══════════════════════════════════════════════════════════════════════════════╗
║     Name     │Version│       Last updated       │ Status │  Package  │   Package    │  Platform  │                               Platform Status                                ║
║              │       │                          │        │   Name    │   Version    │    Name    │                                                                              ║
╠══════════════╪═══════╪══════════════════════════╪════════╪═══════════╪══════════════╪════════════╪══════════════════════════════════════════════════════════════════════════════╣
║helloworldpcf │2      │Tue Oct 24 22:57:02 EDT   │DEPLOYED│helloworld │1.0.0         │cf-dev      │ [helloworldpcf-helloworld-v2], State =                                       ║
║              │       │2017                      │        │           │              │            │ [helloworldpcf-helloworld-v2-0=deployed]                                     ║
╚══════════════╧═══════╧══════════════════════════╧════════╧═══════════╧══════════════╧════════════╧══════════════════════════════════════════════════════════════════════════════╝
----

You can get the full history of the release using the `history` command

[source,bash,options="nowrap"]
----
skipper:>history --release-name helloworldpcf
╔═══════╤════════════════════════════╤════════╤════════════╤═══════════════╤════════════════╗
║Version│        Last updated        │ Status │Package Name│Package Version│  Description   ║
╠═══════╪════════════════════════════╪════════╪════════════╪═══════════════╪════════════════╣
║2      │Tue Oct 24 22:57:02 EDT 2017│DEPLOYED│helloworld  │1.0.0          │Upgrade complete║
║1      │Tue Oct 24 22:54:30 EDT 2017│DELETED │helloworld  │1.0.0          │Delete complete ║
╚═══════╧════════════════════════════╧════════╧════════════╧═══════════════╧════════════════╝
----

A more typical upgrade process is not to change application properties, but to change the version of the application because the code has change.  We will now upgrade the release to use a new maven artifact, version 1.0.1, which also corresponds to version 1.0.1 of the helloworld skipper package.
In this case, we will not add any additional properties other than the route.

[source,bash,options="nowrap"]
----
skipper:>upgrade --release-name helloworldpcf --package-name helloworld --package-version 1.0.1 --properties spec.deploymentProperties.spring.cloud.deployer.cloudfoundry.route=helloworldpcf.cfapps.io
helloworldpcf has been upgraded.  Now at version v3.
----

Note that the current release's property values such as using 2G, or the greeting being `yo` are not carried over.
In a future release we will introduce a `--reuse-properties` command that will carry the current release properties over to the next release to be made.
You can monitor the status of the upgrade using the `status` command

[source,bash,options="nowrap"]
----
skipper:>status --release-name helloworldpcf
╔═══════════════╤═════════════════════════════════════════════════════════════════════════════════╗
║Last Deployed  │Tue Oct 24 23:09:39 EDT 2017                                                     ║
║Status         │DEPLOYED                                                                         ║
║Platform Status│All applications have been successfully deployed.                                ║
║               │[helloworldpcf-helloworld-v3], State = [helloworldpcf-helloworld-v3-0=deployed]  ║
╚═══════════════╧═════════════════════════════════════════════════════════════════════════════════╝
----

And a curl command shows

[source,bash,options="nowrap"]
----
curl http://helloworldpcf.cfapps.io/greeting
Olá Mundo!
$ curl http://helloworldpcf.cfapps.io/about
Hello World v1.0.1.RELEASE
----

Our history now looks like

[source,bash,options="nowrap"]
----
skipper:>history --release-name helloworldpcf
╔═══════╤════════════════════════════╤════════╤════════════╤═══════════════╤════════════════╗
║Version│        Last updated        │ Status │Package Name│Package Version│  Description   ║
╠═══════╪════════════════════════════╪════════╪════════════╪═══════════════╪════════════════╣
║3      │Tue Oct 24 23:09:39 EDT 2017│DEPLOYED│helloworld  │1.0.1          │Upgrade complete║
║2      │Tue Oct 24 22:57:02 EDT 2017│DELETED │helloworld  │1.0.0          │Delete complete ║
║1      │Tue Oct 24 22:54:30 EDT 2017│DELETED │helloworld  │1.0.0          │Delete complete ║
╚═══════╧════════════════════════════╧════════╧════════════╧═══════════════╧════════════════╝
----

Next we will use the `rollback` command to deploy an older version of the application.
Since we have the manifest for that version, we have all we need to redeploy an earlier release.

[source,bash,options="nowrap"]
----
skipper:>rollback --release-name helloworldpcf --release-version 2
helloworldpcf has been rolled back.  Now at version v4.
----

The history now shows a new `v4` version, even though it is identical in terms of app behavior to the `v2` version.

[source,bash,options="nowrap"]
----
skipper:>history --release-name helloworldpcf
╔═══════╤════════════════════════════╤════════╤════════════╤═══════════════╤════════════════╗
║Version│        Last updated        │ Status │Package Name│Package Version│  Description   ║
╠═══════╪════════════════════════════╪════════╪════════════╪═══════════════╪════════════════╣
║4      │Tue Oct 24 23:15:01 EDT 2017│DEPLOYED│helloworld  │1.0.0          │Upgrade complete║
║3      │Tue Oct 24 23:09:39 EDT 2017│DELETED │helloworld  │1.0.1          │Delete complete ║
║2      │Tue Oct 24 22:57:02 EDT 2017│DELETED │helloworld  │1.0.0          │Delete complete ║
║1      │Tue Oct 24 22:54:30 EDT 2017│DELETED │helloworld  │1.0.0          │Delete complete ║
╚═══════╧════════════════════════════╧════════╧════════════╧═══════════════╧════════════════╝
----

The curl commands show
[source,bash,options="nowrap"]
----
$ curl http://helloworldpcf.cfapps.io/greeting
yo
$ curl http://helloworldpcf.cfapps.io/about
Hello World v1.0.0.RELEASE
----

[[tour-kubernetes]]
== Kuberenetes

In this example we will be running the Skipper server on the local machine and deploying to minikube also running on the local machine.

NOTE: The upgrade approach in 1.0 M1 does not handle correctly the routing of http traffic between versions, so take what is below with a grain of salt.  The Spring Cloud Deployer for Kubernetes creates a service, replication controller, and pod for the app (or optionally
  a Deployment)  This is not an issue for apps that communicate via Messaging middleware.  Treat the current M1 release as a WIP.

Start the Skipper server with the option `--spring.config.location=skipper.yml` where the YAML is shown below.

----
spring:
  cloud:
    skipper:
      server:
        enableLocalPlatform: false
        platform:
          kubernetes:
            accounts:
              minikube:
                namespace: default
----

The `repo list` command shows the `experimental` and `local` repositories, since they are configured by default.
[source,bash,options="nowrap"]
----
skipper:>repo list
╔════════════╤═══════════════════════════════════════════════════════════╤═════╤═════╗
║    Name    │                            URL                            │Local│Order║
╠════════════╪═══════════════════════════════════════════════════════════╪═════╪═════╣
║experimental│http://skipper-repository.cfapps.io/repository/experimental│false│0    ║
║local       │http://d4d6d1b6-c7e5-4226-69ec-01d4:7577                   │true │1    ║
╚════════════╧═══════════════════════════════════════════════════════════╧═════╧═════╝
----

and the `search` command shows
[source,bash,options="nowrap"]
----
skipper:>search
╔═════════════════╤═══════╤════════════════════════════════════════════════════════════════════════════════╗
║      Name       │Version│                                  Description                                   ║
╠═════════════════╪═══════╪════════════════════════════════════════════════════════════════════════════════╣
║helloworld       │1.0.1  │The app has two endpoints, /about and /greeting in Portuguese.  Maven resource. ║
║helloworld       │1.0.0  │The app has two endpoints, /about and /greeting in English.  Maven resource.    ║
║helloworld-docker│1.0.1  │The app has two endpoints, /about and /greeting in Portuguese.  Docker resource.║
║helloworld-docker│1.0.0  │The app has two endpoints, /about and /greeting in English.  Docker resource.   ║
╚═════════════════╧═══════╧════════════════════════════════════════════════════════════════════════════════╝
----

The command `platform list` shows which platforms the server has been configured with, in this case just one Kubernetes namespace.  Disabling the local platform with the property `enableLocalPlatform = false` is why the default `local` platform does not appear.

[source,bash,options="nowrap"]
----
skipper:>platform list
╔════════╤══════════╤══════════════════════════════════════════════════════════════════════════════════════╗
║  Name  │   Type   │                                     Description                                      ║
╠════════╪══════════╪══════════════════════════════════════════════════════════════════════════════════════╣
║minikube│kubernetes│master url = [https://192.168.99.100:8443/], namespace = [default], api version = [v1]║
╚════════╧══════════╧══════════════════════════════════════════════════════════════════════════════════════╝
----

Let's install the Hello World app, specifically, the Docker based artifact.
[source,bash,options="nowrap"]
----
skipper:>install --release-name helloworldk8s --package-name helloworld-docker --package-version 1.0.0 --platform-name minikube --properties spec.deploymentProperties.spring.cloud.deployer.kubernetes.createNodePort=32123
Released helloworldk8s. Now at version v1.
----

If you do not specify `--platform-name minikube` the command will fail since the command property defaults to a platform named `default`.  Instead of specifying it, you can register this Kubernetes Platform account in the manifest with the name `default` instead of `minikube`.

You can monitor the process using the `status command`.
[source,bash,options="nowrap"]
----
skipper:>status --release-name helloworldk8s
╔═══════════════╤══════════════════════════════════════════════════════════════════════════════════════════════════╗
║Last Deployed  │Wed Oct 25 17:34:24 EDT 2017                                                                      ║
║Status         │DEPLOYED                                                                                          ║
║Platform Status│The applications are being deployed.                                                              ║
║               │[helloworldk8s-helloworld-docker-v1], State = [helloworldk8s-helloworld-docker-v1-cch68=deploying]║
╚═══════════════╧══════════════════════════════════════════════════════════════════════════════════════════════════╝
----


Eventually the Platform Status will say `All applications have been successfully deployed.`

Note that the status `DEPLOYED` above indicates that Skipper has told the platform to deploy.  Skipper does not keep track of the intermediate states 'deploying' or 'deleting'.

A `kubectl pods` command will now have a new listing for this deployed application
[source,bash,options="nowrap"]
----
$ kubectl get pods
NAME                                       READY     STATUS    RESTARTS   AGE
helloworldk8s-helloworld-docker-v1-g8j39   0/1       Running   0          37s

$ kubectl get service
NAME                                 CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE
helloworldk8s-helloworld-docker-v1   10.0.0.202   <nodes>       8080:32123/TCP   41s
kubernetes                           10.0.0.1     <none>        443/TCP          57m

----

To get the URL of this app on minikube
[source,bash,options="nowrap"]
----
$ minikube service --url helloworldk8s-helloworld-docker-v1
http://192.168.99.100:32123
----

You can now curl the `greeting` endpoint and the `about` endpoint.
[source,bash,options="nowrap"]
----
$ curl http://192.168.99.100:32123/greeting
Hello World!
$ curl http://192.168.99.100:32123/about
Hello World v1.0.0.RELEASE
----

The name of the application is based on the convention <release-name>-<package-name>-v<incrementing-counter>.  This will need to change in future releases in order to handle routing correctly.

The package provides a means to template the application version, application properties and deployment properties that are used to deploy the application to Kubernetes.  The `manifest get` command shows the final YAML file which is passed off to the Spring Cloud Deployer Library.

[source,bash,options="nowrap"]
----
skipper:>manifest get --release-name helloworldk8s

---
# Source: template.yml
apiVersion: skipperPackage/v1
kind: SpringCloudDeployerApplication
metadata:
  name: helloworld-docker
spec:
  resource: docker:springcloud/spring-cloud-skipper-samples-helloworld:1.0.0.RELEASE
  applicationProperties:
  deploymentProperties:
    spring.cloud.deployer.kubernetes.createNodePort: 32123
----

The manifest is in a Kubernetes Resource file inspired format.  By looking at the manifest you can see which Docker images was used and which properties were set before the final push to Kubernetes.
The metadata values that are present will be used in the next release to support searching for releases based on those values.

Since it is somewhat awkward to specify multiple flattened out YAML values for the `--properties` argument in the shell, you can also specify the location of a YAML file when installing or upgrading.
We will use a YAML file when we will update the release.  This application contains a Spring Boot
`@ConfigurationProperty` named `helloworld.greeting`, so we will set that along with a standard Spring Boot property `endpoints.sensitive=false`.  We will also bump the memory up to 2G.

[source,bash,options="nowrap"]
----
spec:
  applicationProperties:
    endpoints.sensitive: false
    helloworld.greeting: yo
  deploymentProperties:
    spring.cloud.deployer.kubernetes.createNodePort: 32124
    spring.cloud.deployer.memory: 2048m
----

The `upgrade` command
[source,bash,options="nowrap"]
----
skipper:>upgrade --release-name helloworldk8s --package-name helloworld-docker --package-version 1.0.0 --file /home/mpollack/helloworld-upgrade-k8s.yml
helloworldk8s has been upgraded.  Now at version v2.
----

This will start another instance of the hello world application. If you do not specify `--package-version` it will pick
the latest version of the `helloworld-docker` package.  You do not need to specify the `--platform-name` as it will
always be where the current application was deployed.


the `kubectl get all` command shows
[source,bash,options="nowrap"]
----
$ kubectl get all
NAME                                          READY     STATUS    RESTARTS   AGE
po/helloworldk8s-helloworld-docker-v1-g8j39   1/1       Running   0          2m
po/helloworldk8s-helloworld-docker-v2-jz85l   0/1       Running   0          50s

NAME                                    DESIRED   CURRENT   READY     AGE
rc/helloworldk8s-helloworld-docker-v1   1         1         1         2m
rc/helloworldk8s-helloworld-docker-v2   1         1         0         50s

NAME                                     CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE
svc/helloworldk8s-helloworld-docker-v1   10.0.0.202   <nodes>       8080:32123/TCP   2m
svc/helloworldk8s-helloworld-docker-v2   10.0.0.154   <nodes>       8080:32124/TCP   51s
svc/kubernetes                           10.0.0.1     <none>        443/TCP          59m
----

At this point Skipper is looking to see if the health endpoint of the Boot application is ok.
The property `spring.cloud.skipper.server.strategies.healthcheck.timeoutInMillis` is the maximum time the upgrade process will wait for a healthy app.
The default value is 5 minutes.
Skipper will fail the deployment if it is not healthy within that time.
The property `spring.cloud.skipper.server.strategies.healthcheck.sleepInMillis` is how long to sleep between health checks.

The current upgrade strategy is very simple, if the new app is healthy, the old app is removed.  There is not a rolling upgrade option, all new apps are deployed, checked for health, and then previous versions removed.
More flexible upgrade strategies are planned along with the introduction of the https://projects.spring.io/spring-statemachine/[Spring Cloud State Machine] project to orchestrate the update process.


You can now curl the `greeting` endpoint and the `about` endpoint.

[source,bash,options="nowrap"]
----
$ curl http://192.168.99.100:32124/greeting
yo
$ curl http://192.168.99.100:32124/about
Hello World v1.0.0.RELEASE
----


The `list` command shows you the current `DEPLOYED` and `DELETED` release for every release name.
In this case there is just one entry
[source,bash,options="nowrap"]
----
skipper:>list
╔═════════════╤═══════╤════════════════════════════╤════════╤═════════════════╤═══════════════╤═════════════╤═══════════════╗
║    Name     │Version│        Last updated        │ Status │  Package Name   │Package Version│Platform Name│Platform Status║
╠═════════════╪═══════╪════════════════════════════╪════════╪═════════════════╪═══════════════╪═════════════╪═══════════════╣
║helloworldk8s│2      │Wed Oct 25 17:36:16 EDT 2017│DEPLOYED│helloworld-docker│1.0.0          │minikube     │               ║
╚═════════════╧═══════╧════════════════════════════╧════════╧═════════════════╧═══════════════╧═════════════╧═══════════════╝
----

You can get the full history of the release using the `history` command.

----
skipper:>history --release-name helloworldk8s
╔═══════╤════════════════════════════╤════════╤═════════════════╤═══════════════╤════════════════╗
║Version│        Last updated        │ Status │  Package Name   │Package Version│  Description   ║
╠═══════╪════════════════════════════╪════════╪═════════════════╪═══════════════╪════════════════╣
║2      │Wed Oct 25 17:36:16 EDT 2017│DEPLOYED│helloworld-docker│1.0.0          │Upgrade complete║
║1      │Wed Oct 25 17:34:24 EDT 2017│DELETED │helloworld-docker│1.0.0          │Delete complete ║
╚═══════╧════════════════════════════╧════════╧═════════════════╧═══════════════╧════════════════╝
----
A more typical upgrade process is not to change application properties, but to change the version of the application because the code has change.  We will now upgrade the release to use a new Docker artifact, version 1.0.1, which also corresponds to version 1.0.1 of the helloworld Skipper package.
In this case we will not add any additional properties other than the NodePort.

[source,bash,options="nowrap"]
----
skipper:>upgrade --release-name helloworldk8s --package-name helloworld-docker --package-version 1.0.1 --properties spec.deploymentProperties.spring.cloud.deployer.kubernetes.createNodePort=32125
Released helloworldk8s. Now at version v3.
----

Note that the the current release's property values such as using 2G, or the greeting being `yo` are not carried over.
In a future release we will introduce a `--reuse-properties` command that will carry the current release properties over to the next release to be made.
You can monitor the status of the upgrade using the `status` command

[source,bash,options="nowrap"]
----
skipper:>status --release-name helloworldk8s
╔═══════════════╤══════════════════════════════════════════════════════════════════════════════════════════════════╗
║Last Deployed  │Wed Oct 25 17:41:33 EDT 2017                                                                      ║
║Status         │DEPLOYED                                                                                          ║
║Platform Status│All applications have been successfully deployed.                                                 ║
║               │[helloworldk8s-helloworld-docker-v3], State = [helloworldk8s-helloworld-docker-v3-sb59j=deployed] ║
╚═══════════════╧══════════════════════════════════════════════════════════════════════════════════════════════════╝
----

And a curl command shows
[source,bash,options="nowrap"]
----
$ curl http://192.168.99.100:32125/greeting
Olá Mundo!

$ curl http://192.168.99.100:32125/about
Hello World v1.0.1.RELEASE
----

Our history now looks like
[source,bash,options="nowrap"]
----
skipper:>history --release-name helloworldk8s
╔═══════╤════════════════════════════╤════════╤═════════════════╤═══════════════╤════════════════╗
║Version│        Last updated        │ Status │  Package Name   │Package Version│  Description   ║
╠═══════╪════════════════════════════╪════════╪═════════════════╪═══════════════╪════════════════╣
║3      │Wed Oct 25 17:41:33 EDT 2017│DEPLOYED│helloworld-docker│1.0.1          │Upgrade complete║
║2      │Wed Oct 25 17:36:16 EDT 2017│DELETED │helloworld-docker│1.0.0          │Delete complete ║
║1      │Wed Oct 25 17:34:24 EDT 2017│DELETED │helloworld-docker│1.0.0          │Delete complete ║
╚═══════╧════════════════════════════╧════════╧═════════════════╧═══════════════╧════════════════╝
----

Next we will use the `rollback` command to deploy an older version of the application.
Since we have the manifest for that version, we have all we need to redeploy an earlier release.

[source,bash,options="nowrap"]
----
skipper:>rollback --release-name helloworldk8s --release-version 2
helloworldk8s has been rolled back.  Now at version v4.
----

The history now shows a new `v4` version, even though it is identical to the `v2` version.

[source,bash,options="nowrap"]
----
skipper:>history --release-name helloworldk8s
╔═══════╤════════════════════════════╤════════╤═════════════════╤═══════════════╤════════════════╗
║Version│        Last updated        │ Status │  Package Name   │Package Version│  Description   ║
╠═══════╪════════════════════════════╪════════╪═════════════════╪═══════════════╪════════════════╣
║4      │Wed Oct 25 17:44:25 EDT 2017│DEPLOYED│helloworld-docker│1.0.0          │Upgrade complete║
║3      │Wed Oct 25 17:41:33 EDT 2017│DELETED │helloworld-docker│1.0.1          │Delete complete ║
║2      │Wed Oct 25 17:36:16 EDT 2017│DELETED │helloworld-docker│1.0.0          │Delete complete ║
║1      │Wed Oct 25 17:34:24 EDT 2017│DELETED │helloworld-docker│1.0.0          │Delete complete ║
╚═══════╧════════════════════════════╧════════╧═════════════════╧═══════════════╧════════════════╝
----

The curl commands show
[source,bash,options="nowrap"]
----
$ curl http://192.168.99.100:32124/greeting
yo
$ curl http://192.168.99.100:32124/about
Hello World v1.0.0.RELEASE
----
